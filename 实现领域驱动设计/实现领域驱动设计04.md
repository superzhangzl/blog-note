# 第4章 架构



> 本章学习路线图
>
> - 听听SaaSOvation的CIO是如何做项目回顾的
> - 学习使用依赖注入原则（DIP）和六边形（Hexagonal）架构来改进分层架构（Layer Architecture）
> - 学习六边形架构对SOA和REST的支
> - 学习数据网织（DataFabric）或基于网格的分布式缓存（Grid-Based Distributed Cache）和事件驱动风格
> - 学习DDD世界的新架构模式——CQRS
> - 学习SaaSOvation所才用的架构



DDD的一大好处便是它并不需要使用特定的架构。由于核心域位于界限上下文中，我们可以在整个系统中使用多种风格的结构。质量驱动的架构选择是种风险驱动方式，即我们采用的架构是减少失败风险的，而不是增加失败风险的。



## 采访一个成功的CIO

> 访谈过程略，摘抄几句对话要点

- 随着软件复杂性的增加，我们需要引入**单元测试**和**功能测试**来保证软件质量。
- 采用**聚合模式**和**资源库**，在开发时可以采用内存持久化，因为使用了相同的资源库接口，之后又可以方便地切换到其他持久化机制。
- 有些功能需要一系列分布式处理，为了不让用户久等，引入了一套完整的**事件驱动架构**，使用管道和过滤器来完成该功能。
- 某些要求需要跟踪对系统的每一次改变，解决这个事情最好的方式便是**事件源**。



## 分层

在分层架构中，我们将领域模型和业务逻辑分离出来，并减少对特定基础设施、用户界面甚至应用层逻辑的依赖，因为他们不属于业务逻辑。将一个复杂的系统分为不同的层，每层都应该具有良好的内聚性，并且只依赖于比其自身更低的层。

如图所示为一个典型的DDD传统分层结构，其中核心域只位于架构中的其中一层，上面是用户界面层和应用层，下面是基础设施层。

![DDD所使用的传统分层架构](实现领域驱动设计04.assets/DDD所使用的传统分层架构.png)



分层架构的一个重要原则是：每层只能与位于其下方的层发生耦合。用户界面只用于处理用户显示和用户请求，它不应该包含领域或业务逻辑。（其他特殊情况可以灵活，但原则不变）

当领域模型用于发布**领域事件**时，应用层可以将订阅方注册到任意数量的事件上，这样的好处是可以对事件进行存储和转发；同时领域模型只需要关注自己的核心逻辑；**领域事件发布器**可以保持轻量化而不依赖消息机制的基础设施。

有时，领域层多少需要使用到基础设施层，比如持久化机制。遵从分层架构原则并不意味领域对象要与基础设施层发生直接耦合，此时我们可以才用**模块**的方式来因层细节。

> `com.saasovation.agilepm.domain.model.product.impl`

更好的办法参考下文的“依赖倒置原则”，调整一下分层架构中各层的顺序。



### 依赖倒置原则

依赖倒置原则定义：

- 高层模块不应该依赖于底层模块，两者都应该依赖于抽象
- 抽象不应该依赖于细节，细节应该依赖于抽象。

根据该定义，低层服务应该依赖于高层组件所提供的接口。架构中才用依赖倒置原则有多种表达方式，我们选择其中一种，如图所示：

todo

当我们将关注点放在领域层上，采用依赖倒置原则，使领域层和基础设施层都只依赖于由领域模型所定义的抽象接口。由于应用层是领域层的直接客户，它将依赖于领域层的接口，并间接的访问资源库和由基础设施层提供的实现类。应用层可以采用不同的方式来获取这些实现，包括**依赖注入**、**服务工厂**和**插件**。



## 六边形架构（端口与适配器）

在六边形架构中，不同的客户通过”平等“的方式进行交互。当需要新客户时，只需要添加一个新的适配器将客户输入转化成能被系统API理解的参数就可以。对于每种特定的输出，都有一个新建的适配器负责完成相应的转化功能。并且依赖注入的架构自然而然地具有端口与适配器的风格。

我们通常将客户与系统交互的地方称为”前端“，同样将系统中获取、存储持久化数据和发送输出数据的地方称为”后端“。在六边形架构中存在两个区域，分别是”外部区域“和”内部区域“。在外部区域中，不同的客户均可以提交输入；而内部的系统则用于获取持久化数据，并对程序输出进行存储（如数据库），或者中途将输出转发到另外的地方。

六边形每条边都代表不同类型的端口，要么处理输入，要么处理输出。端口可以很灵活的使用诸如http、AMQP等协议进行交互，主要在相应的时刻有相应的适配器处理即可。

TODO 图4.4

六边形架构的好处之一在于我们可以轻易的开发用于测试的适配器，整个领域模型和应用程序可以在没有客户和存储机制的条件下进行设计开发。这样我可能可以在核心域上进行持续开发，而不需要考虑支撑性的技术组件。



## 面向服务架构

面向服务架构SOA，书中展示由ThomasEr给出的一些SOA原则。服务除了拥有互操作性外，还具有一下8种设计原则。

| 服务设计原则 | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| 服务契约     | 通过契约文档，服务阐述自身的目的与功能                       |
| 松耦合       | 服务将依赖关系最小化                                         |
| 服务抽象     | 服务只发布契约，而向客户隐藏内部逻辑                         |
| 服务重用性   | 一种服务可以被其他服务所重用                                 |
| 服务自治性   | 服务自行控制环境与资源以保持独立性，这有助于保持服务的一致性和可靠性 |
| 服务无状态性 | 服务负责消费方的状态管理，这不能与服务的自治性发生冲突       |
| 服务可发现性 | 客户可以通过服务元数据来查找服务和理解服务                   |
| 服务组合性   | 一种服务可以由其他服务组合而成，而不管其他服务的大小和复杂性如何 |



消费方可以通过REST、SOAP和消息机制获取服务。一个六边形架构系统支持多种类型的服务端点（endpoint），这依赖于DDD是如何应用于SOA的。 针对SOA的定义和价值存在的歧义可以在某一点达成一致：**业务服务可以由任意数目的技术服务来提供**。技术服务可以是REST资源、SOAP接口或者消息类型。业务服务强调业务战略，即如何对业务和技术进行整合。

在使用DDD时，我们所创建的界限上下文应该包含一个完整的，能很好的表达通用语言的领域模型。架构不应该对领域模型的大小产生影响，但如果一个或多个技术服务端点会决定到界限上下文的大小，结果会产生许多非常小的界限上下文和领域模型。对于通用语言来说，这种方式会起到分化破坏作用。



## REST

### REST作为一种架构风格

架构风格之于架构就像设计模式之于设计一样。它将不同架构实现所共有的东西抽象出来，使得我们在谈及架构时不至于陷入到技术细节中。分布式系统架构存在着多种架构风格，包括客户端-服务器架构风格和分布式对象风格。而REST就应该是属于Web架构的一种架构风格。



### RESTful HTTP服务器的关键方面

略



### RETSful HTTP客户端的关键方面

略



### REST和DDD

不建议将领域模型直接暴露给外界，因为这样会使得系统变得脆弱，原因在于对领域模型的每次改变都会导致对系统接口的改变。将两种方式结合有两种方法。

第一种方法是为系统接口层单独创建一个界限上下文，再在此上下文中通过适当的策略来访问实际的核心模型。它将系统看做一个整体，通过资源抽象将系统功能暴露给外界，而不是通过服务或者远程接口。这种方法应该被优先考虑，因为它在核心域和系统接口模型之间完成了解耦，使得我们可以先做修改，再决定哪些修改应该反应到系统接口模型上。

另一种方法用于需要使用标准媒体类型的时候。我们可以创建一个领域模型来处理每一种媒体类型，并且能在服务器和客户端之间进行重用。





























