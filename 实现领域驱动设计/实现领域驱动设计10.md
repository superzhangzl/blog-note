# 第10章 聚合

> 本章学习路线图
>
> - 以SaaSOvation为例，学习对聚合的不当建模所带来的负面影响
> - 学习设计聚合的经验原则，并形成一套最佳实践
> - 根据真实的业务规则，掌握如何在一致性边界中对真正的不变条件进行建模
> - 学习一个聚合为什么应该通过标识（identity）去引用另一个聚合
> - 了解在聚合边界之外使用最终一致性的重要性
> - 学习聚合的实现技术，包括“告诉而非询问”原则和迪米特法则

将实体（5）和值对象（6）在一致性边界之内组成聚合。有很多途径都将导致我们建立不正确的聚合模型，我们应该将注意力集中在业务规则上来避免各种不良情况。



## 在Scrum核心领域中使用聚合

本章书中以SaaSOvation团队的ProjectOvation项目的敏捷项目管理上下文为例，通过Scrum项目建立模型的过程来给出了使用聚合的分析思路。

> 聚合模型讨论的是对象组合和信息隐藏，此外还包含了一致性边界和事务。



## 原则：在一致性边界之内建模真正的不变条件

要从限界上下文中发现聚合，我们需要了解模型中真正的不变条件。只有这样，我们才能决定什么样的对象可以放在一个聚合中。这里的不变条件表示一个业务规则，该规则应该总是保持一致性的。聚合边界之内的所有内容组成了一套不变的业务规则，任何操作都不能违背这些规则。边界之外的任何东西与该聚合都是不相关的。

在讨论不变条件时，我们讨论的是事务一致性。在设计聚合时，我们主要关注的是聚合的一致性边界，而不是创建一个对象树。

> 在一个事务中只能修改一个聚合实例。



## 原则：设计小聚合

对于大聚合，即便我们可以保证事务的成功执行，它依然有可能限制系统的性能和可伸缩性。系统性能和可伸缩性虽然是非功能性需求，但是我们绝不应该予以忽视。

> 属于DFX特性，具体详见《[何所谓DFX-云社区-华为云](https://bbs.huaweicloud.com/blogs/111852)》

如果我们要设计小的聚合，好的做法是使用根实体（Root Entity）来表示聚合，其中只包含最小数量的属性或者值类型属性。

> 这里的值类型属性即引用了值对象的属性，这里主要是为了与那些原始类型区分开来。

哪些属性是所需的呢？简单的答案是：那些必须与其他属性保持一致的属性。比如一个Product拥有name和desc属性，这里的name和desc是需要保持一致的，将它们放在两个不同的聚合中显然是没有意义的。

将聚合的内部建模成值对象有很多好处，根据你所选用的持久化机制，值对象可以随着根实体而序列化，而实体则需要单独的存储区域予以跟踪。再者由于值对象是不变的，测试起来也相对简单。

小聚合不仅有性能和可伸缩性上的好处，它还有助于事务的成果执行，即它可以减少事务提交冲突。



## 原则：通过唯一标识引用其他聚合

我们应该优先考虑通过全局唯一标识来引用外部聚合，而不是通过直接的对象引用。

> 通过这种方式创建的聚合也会变得更小，模型的性能也将随之变好。



### 建模对象导航性

在调用聚合行为方法之前，使用资源库或**领域服务（7）**来获取所需要的对象。**不管使用哪种方式在一个聚合中引用另外的聚合，我们都不能在同一个事务中修改多个聚合实例。**



## 原则：在边界之外使用最终一致性

任何跨聚合的业务规则都不能总是保持处于最新状态。通过事件处理、批处理或者其他更新机制，我们可以在一定时间之内处理好他方依赖。因此当在一个聚合上执行命令方法时，如果还需要在其他的聚合上执行额外的业务规则，那么请使用最终一致性。

DDD有一种很实用的方法可以支持最终一致性，即一个聚合的命令方法所发布的领域事件及时地发送给异步的订阅方。

```java
DomainEventPublisher()
    .instance()
    .publish(event);
```



对于一致性的选择，有一个简单而使用的指导原则。对于一个用例，问问是否应该由执行该用例的用户来保证数据的一致性。如果是，请使用事务一致性，当然此时依然需要遵循其他聚合原则。如果需要其他用户或者系统来保证数据一致性，请使用最终一致性。



## 打破原则的理由

又是肯呢个需要在单个事务中更新多个聚合实例，这么做的理由有：

1. 方便用户界面
2. 缺乏技术机制
3. 全局事务
4. 查询性能

我们将尽可能保证一致性，并且致力于创建高性能的、高可伸缩性的系统。



## 通过发现，深入理解

















